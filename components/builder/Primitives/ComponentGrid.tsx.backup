'use client'

import * as React from 'react'
import { FlowBlock } from '@/types/domain'
import { Cell } from './Cell'
import { HierarchicalCellComponent } from '@/components/builder/Blocks/Common/HierarchicalCell'
import { HierarchicalCell, HierarchicalCellUtils } from '@/types/hierarchicalCell'
import { 
  calculateBlocksLayout, 
  generateGridStyle,
  generateHierarchicalGridStyle,
  getBlockNameGridArea,
  getHeaderGridArea,
  getBodyGridArea,
  calculateHierarchicalLayout,
  getHierarchicalCellGridArea,
  isDivisionBlock,
  ComponentGridInfo,
  BlockGridInfo 
} from '@/lib/grid/GridCalculator'
import { BlockGridCalculator } from '@/lib/blockManager'
import { logBlockAsDbFormat } from '@/utils/blockToDbConverter'
import { Trash2, Link2, ArrowLeft, ArrowRight, X, Eye } from 'lucide-react'

// Connection íƒ€ì… ì •ì˜
interface Connection {
  id: string
  sourceGridId: number
  targetGridId: number
  sourceHandle: 'left' | 'right'
  targetHandle: 'left' | 'right'
}

// DivisionGrid ì „ìš© ê°„ë‹¨ ìƒíƒœ (ComponentGrid_Rulesë§Œ ì¤€ìˆ˜)
type DivisionCellMerge = { rowspan: number; hidden: boolean }
type DivisionGridState = {
  rows: number
  cols: number
  merges: Record<number, Record<number, DivisionCellMerge>>
}

interface ComponentGridProps {
  blocks: FlowBlock[]
  gridId?: number
  onBlockChange?: (blockId: number, path: (string | number)[], value: any) => void
  initialHierarchicalDataMap?: Record<number, HierarchicalCell[]>
  onBlockCombine?: (blockId: number, side?: 'left' | 'right') => void
  onAddColumn?: (blockId: number) => void
  onInsertRow?: (rowIndex: number) => void
  combineState?: {
    isCombineMode: boolean
    sourceBlockId: string | null
    targetBlockId: string | null
  }
  onBlockDelete?: (blockId: number) => void
  connections?: Connection[]
  onConnectionCreate?: (sourceId: number, targetId: number) => void
  onConnectionDelete?: (connectionId: string) => void
}

export const ComponentGrid: React.FC<ComponentGridProps> = ({
  blocks,
  gridId,
  onBlockChange,
  initialHierarchicalDataMap,
  onBlockCombine,
  onAddColumn,
  onInsertRow,
  combineState,
  onBlockDelete,
  connections = [],
  onConnectionCreate,
  onConnectionDelete
}) => {
  // ì•ˆì •ì ì¸ gridId ìƒì„± (propsì—ì„œ ì œê³µë˜ì§€ ì•Šì€ ê²½ìš°)
  const stableGridId = React.useMemo(() => {
    if (gridId !== undefined) {
      return gridId
    }
    
    // blocks ê¸°ë°˜ìœ¼ë¡œ ì•ˆì •ì ì¸ ID ìƒì„±
    if (blocks.length > 0) {
      const blockIds = blocks.map(b => b.id).sort().join('-')
      const hash = blockIds.split('').reduce((a, b) => {
        a = ((a << 5) - a) + b.charCodeAt(0)
        return a & a
      }, 0)
      return Math.abs(hash) % 100000 // 0-99999 ë²”ìœ„ì˜ ì–‘ìˆ˜
    }
    
    // fallback: í˜„ì¬ ì‹œê°„ ê¸°ë°˜ ID (í˜ì´ì§€ ë¡œë“œë‹¹ í•œ ë²ˆë§Œ ìƒì„±)
    return Date.now() % 100000
  }, [gridId, blocks])
  
  // DivisionBlock ì „ìš© ê°„ë‹¨ í…Œì´ë¸” ìƒíƒœ
  const [divisionGridStateMap, setDivisionGridStateMap] = React.useState<Record<number, DivisionGridState>>({})
  
  const gridInfo = React.useMemo(() => calculateBlocksLayout(blocks, divisionGridStateMap), [blocks, divisionGridStateMap])

  // ê° ë¸”ë¡ì˜ ê³„ì¸µ ë°ì´í„° ìƒíƒœ ê´€ë¦¬ (êµ¬ë¶„ ë¸”ë¡ìš©)
  const [hierarchicalDataMap, setHierarchicalDataMap] = React.useState<Record<number, HierarchicalCell[]>>(() => initialHierarchicalDataMap ?? {})

  // ì™¸ë¶€ì—ì„œ ì „ë‹¬ëœ ì´ˆê¸° ë§µì´ ë°”ë€Œë©´ ë™ê¸°í™” (ìµœì´ˆ ë¡œë“œ/ì¬ë¡œë“œ ë°˜ì˜)
  React.useEffect(() => {
    if (initialHierarchicalDataMap) {
      setHierarchicalDataMap(prev => ({ ...initialHierarchicalDataMap, ...prev }))
    }
  }, [initialHierarchicalDataMap])
  
  // blocksê°€ ë³€ê²½ë  ë•Œ divisionGridStateMap ì´ˆê¸°í™”
  React.useEffect(() => {
    const newDivisionGridStateMap: Record<number, DivisionGridState> = {}
    
    blocks.forEach(block => {
      if (isDivisionBlock(block)) {
        // BlockGridCalculatorë¥¼ ì‚¬ìš©í•˜ì—¬ ì •í™•í•œ í¬ê¸° ê³„ì‚°
        const gridSize = BlockGridCalculator.calculateGridSize(block)
        
        newDivisionGridStateMap[block.id] = {
          rows: gridSize.rows,
          cols: gridSize.cols,
          merges: {}
        }
        
        // merges ì´ˆê¸°í™” (ëª¨ë“  ì…€ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •)
        for (let r = 0; r < gridSize.rows; r++) {
          newDivisionGridStateMap[block.id].merges[r] = {}
          for (let c = 0; c < gridSize.cols; c++) {
            newDivisionGridStateMap[block.id].merges[r][c] = {
              rowspan: 1,
              hidden: false
            }
          }
        }
      }
    })
    
    setDivisionGridStateMap(newDivisionGridStateMap)
  }, [blocks])
  
  // ì—°ê²° ë“œë˜ê·¸ ìƒíƒœ ê´€ë¦¬ (useRefë¡œ ì¦‰ì‹œ ì ‘ê·¼ ê°€ëŠ¥í•˜ê²Œ)
  const connectionDragRef = React.useRef({
    isDragging: false,
    sourceGridId: null as number | null,
    sourceHandle: null as 'left' | 'right' | null,
    targetGridId: null as number | null,
    targetHandle: null as 'left' | 'right' | null
  })
  
  const [connectionDragState, setConnectionDragState] = React.useState<{
    isDragging: boolean
    sourceGridId: number | null
    sourceHandle: 'left' | 'right' | null
    targetGridId: number | null
    targetHandle: 'left' | 'right' | null
  }>({
    isDragging: false,
    sourceGridId: null,
    sourceHandle: null,
    targetGridId: null,
    targetHandle: null
  })

  // ë‚´ë¶€ ì—°ê²° ìƒíƒœ ê´€ë¦¬ (propsë¡œ ì „ë‹¬ë˜ì§€ ì•Šì€ ê²½ìš° ëŒ€ë¹„)
  const [internalConnections, setInternalConnections] = React.useState<Connection[]>([])
  const activeConnections = connections?.length ? connections : internalConnections

  // blocksê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ êµ¬ë¶„ ë¸”ë¡ì— ëŒ€í•´ ì´ˆê¸° ë°ì´í„° ìƒì„±
  React.useEffect(() => {
    const newMap = { ...hierarchicalDataMap }
    const newDivisionMap = { ...divisionGridStateMap }
    let hasChanges = false
    let hasDivisionChanges = false
    
    blocks.forEach(block => {
      if (isDivisionBlock(block) && !newMap[block.id]) {
        // êµ¬ë¶„ ë¸”ë¡ì¸ë° ì•„ì§ ë°ì´í„°ê°€ ì—†ëŠ” ê²½ìš° ìƒ˜í”Œ ê³„ì¸µ ë°ì´í„° ìƒì„±
        newMap[block.id] = (hierarchicalDataMap[block.id] ?? createSampleHierarchy())
        hasChanges = true
      }
      if (isDivisionBlock(block) && !newDivisionMap[block.id]) {
        // DivisionGrid ê¸°ë³¸ ìƒíƒœ: 1í–‰, ë¸”ë¡ì˜ í˜„ì¬ í—¤ë” ê°œìˆ˜
        const cols = Math.max(1, Array.isArray(block.type.header) ? block.type.header.length : 1)
        newDivisionMap[block.id] = { rows: 1, cols, merges: {} }
        hasDivisionChanges = true
      }
    })
    
    if (hasChanges) {
      setHierarchicalDataMap(newMap)
    }
    if (hasDivisionChanges) {
      setDivisionGridStateMap(newDivisionMap)
    }
  }, [blocks, hierarchicalDataMap, divisionGridStateMap])

  // êµ¬ë¶„ ë¸”ë¡ìš© ì—´ ì¶”ê°€ í•¸ë“¤ëŸ¬
  const handleAddColumnForDivisionBlock = React.useCallback((blockId: number) => {
    // ê°„ë‹¨ í…Œì´ë¸” ìƒíƒœ(colCount) ì—…ë°ì´íŠ¸
    setDivisionGridStateMap(prev => {
      const cur = prev[blockId]
      if (!cur) return prev
      const next: DivisionGridState = {
        rows: cur.rows,
        cols: cur.cols + 1,
        merges: { ...cur.merges }
      }
      // ìƒˆ ì—´ì˜ ëª¨ë“  í–‰ì€ hidden: false, rowspan: 1 ê¸°ë³¸
      for (let r = 0; r < next.rows; r++) {
        next.merges[r] = next.merges[r] || {}
        next.merges[r][cur.cols] = { rowspan: 1, hidden: false }
      }
      return { ...prev, [blockId]: next }
    })

    setHierarchicalDataMap(prev => {
      const blockData = prev[blockId] || []
      
      // ìƒˆë¡œìš´ ë£¨íŠ¸ ë ˆë²¨ ì…€ ìƒì„± (ìƒˆ ì—´ì„ ìœ„í•œ)
      const newRootCell: HierarchicalCell = {
        id: HierarchicalCellUtils.generateId(),
        type: '',
        value: {},
        level: 0,
        children: [],
        parent: undefined
      }
      
      const updatedData = [...blockData, newRootCell]
      return { ...prev, [blockId]: HierarchicalCellUtils.updateRowspans(updatedData) }
    })

    // ë¸”ë¡ì˜ header ë°ì´í„°ë„ ì—…ë°ì´íŠ¸ (onBlockChange í˜¸ì¶œ)
    const targetBlock = blocks.find(b => b.id === blockId)
    if (targetBlock && isDivisionBlock(targetBlock)) {
      // í˜„ì¬ header ë°°ì—´ì— ìƒˆë¡œìš´ í—¤ë” ìš”ì†Œ ì¶”ê°€
      const currentHeaders = targetBlock.type.header || []
      const newHeaderElement = {
        type: 'Token' as const,
        menu_key: 'division_criteria',
        value: '',
        visible: true,
        optional: false
      }
      const updatedHeaders = [...currentHeaders, newHeaderElement]
      
      // hierarchicalDataMap ì—…ë°ì´íŠ¸ í›„ ì¦‰ì‹œ ìµœì‹  ë°ì´í„° ì‚¬ìš©
      setHierarchicalDataMap(prev => {
        const updatedData = prev[blockId] || []
        
        // ì—…ë°ì´íŠ¸ëœ ë¸”ë¡ íƒ€ì…ìœ¼ë¡œ onBlockChange í˜¸ì¶œ (ìµœì‹  children ë°ì´í„° í¬í•¨)
        const updatedBlockType = {
          ...targetBlock.type,
          header: updatedHeaders,
          children: updatedData
        }
        onBlockChange?.(blockId, ['type'], updatedBlockType)
        
        return prev // hierarchicalDataMapì€ ì´ë¯¸ ìœ„ì—ì„œ ì—…ë°ì´íŠ¸ë¨
      })
    }
  }, [blocks, onBlockChange, hierarchicalDataMap])

  // DivisionGrid: ì „ì—­ í–‰ ì‚½ì… + ë³‘í•© ê·œì¹™ ì ìš© (N,M ê¸°ì¤€)
  const handleDivisionAddRow = React.useCallback((blockId: number, row: number, col: number) => {
    // ì „ì—­ í–‰ ì‚½ì… (N+1)
    onInsertRow?.(row + 1)

    setDivisionGridStateMap(prev => {
      const cur = prev[blockId]
      if (!cur) return prev

      // í–‰ ì‚½ì…ì„ ìœ„í•´ mergesë¥¼ ì•„ë˜ë¡œ ì‰¬í”„íŠ¸
      const nextMerges: Record<number, Record<number, DivisionCellMerge>> = {}
      for (let r = 0; r < cur.rows + 1; r++) {
        if (r <= row) {
          nextMerges[r] = { ...(cur.merges[r] || {}) }
        } else {
          // r > n: ê¸°ì¡´ r-1 í–‰ì„ ë³µì‚¬í•´ì„œ ì•„ë˜ë¡œ ì´ë™
          nextMerges[r] = { ...(cur.merges[r - 1] || {}) }
        }
      }

      // ìƒˆë¡œ ì‚½ì…ëœ N+1 í–‰ì˜ ì´ˆê¸°í™”: hidden: false, rowspan: 1
      nextMerges[row + 1] = nextMerges[row + 1] || {}
      for (let c = 0; c < cur.cols; c++) {
        nextMerges[row + 1][c] = { rowspan: 1, hidden: false }
      }

      // ë³‘í•© ê·œì¹™: M > 0ì´ë©´ (N,M-1) rowspan += 1 ë° (N+1,M-1) hidden
      if (col > 0) {
        nextMerges[row] = nextMerges[row] || {}
        nextMerges[row][col - 1] = nextMerges[row][col - 1] || { rowspan: 1, hidden: false }
        nextMerges[row][col - 1].rowspan = Math.max(1, nextMerges[row][col - 1].rowspan) + 1

        nextMerges[row + 1] = nextMerges[row + 1] || {}
        nextMerges[row + 1][col - 1] = { rowspan: 1, hidden: true }
      }

      const next: DivisionGridState = {
        rows: cur.rows + 1,
        cols: cur.cols,
        merges: nextMerges
      }
      return { ...prev, [blockId]: next }
    })
  }, [onInsertRow])

  // ì—°ê²° ë“œë˜ê·¸ í•¸ë“¤ëŸ¬ë“¤
  const handleConnectionStart = React.useCallback((sourceGridId: number, handle: 'left' | 'right') => {
    const newState = {
      isDragging: true,
      sourceGridId: sourceGridId,
      sourceHandle: handle,
      targetGridId: null,
      targetHandle: null
    }
    
    // refë¥¼ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    connectionDragRef.current = newState
    
    // stateë„ ì—…ë°ì´íŠ¸ (UI ë°˜ì˜ìš©)
    setConnectionDragState(newState)
  }, [stableGridId])

  const handleConnectionEnd = React.useCallback((targetGridId: number, targetHandle: 'left' | 'right') => {
    const currentDragState = connectionDragRef.current
    
    if (currentDragState.isDragging && currentDragState.sourceGridId !== null && currentDragState.sourceHandle !== null) {
      // ê°™ì€ ê·¸ë¦¬ë“œì— ì—°ê²°í•˜ëŠ” ê²ƒì€ ë°©ì§€
      if (currentDragState.sourceGridId !== targetGridId) {
        // Connection ê°ì²´ ìƒì„±
        const newConnection: Connection = {
          id: `connection-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          sourceGridId: currentDragState.sourceGridId,
          targetGridId: targetGridId,
          sourceHandle: currentDragState.sourceHandle,
          targetHandle: targetHandle
        }
        
        // ë‚´ë¶€ ìƒíƒœ ì—…ë°ì´íŠ¸ (propsë¡œ connectionsê°€ ê´€ë¦¬ë˜ì§€ ì•ŠëŠ” ê²½ìš°)
        if (!connections || connections.length === 0) {
          setInternalConnections(prev => {
            const updated = [...prev, newConnection]
            return updated
          })
        }
        
        onConnectionCreate?.(currentDragState.sourceGridId, targetGridId)
      }
    }
    
    // refì™€ state ëª¨ë‘ ì´ˆê¸°í™”
    const resetState = {
      isDragging: false,
      sourceGridId: null,
      sourceHandle: null,
      targetGridId: null,
      targetHandle: null
    }
    connectionDragRef.current = resetState
    setConnectionDragState(resetState)
  }, [onConnectionCreate, connections, internalConnections])

  const handleConnectionCancel = React.useCallback(() => {
    const resetState = {
      isDragging: false,
      sourceGridId: null,
      sourceHandle: null,
      targetGridId: null,
      targetHandle: null
    }
    connectionDragRef.current = resetState
    setConnectionDragState(resetState)
  }, [])

  // Escape í‚¤ë¡œ ë“œë˜ê·¸ ì·¨ì†Œ
  React.useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && connectionDragState.isDragging) {
        handleConnectionCancel()
      }
    }

    if (connectionDragState.isDragging) {
      document.addEventListener('keydown', handleEscape)
    }

    return () => {
      document.removeEventListener('keydown', handleEscape)
    }
  }, [connectionDragState.isDragging, handleConnectionCancel])

  // ë‚´ë¶€ ì—°ê²° ì‚­ì œ í•¸ë“¤ëŸ¬
  const handleInternalConnectionDelete = React.useCallback((connectionId: string) => {
    setInternalConnections(prev => prev.filter(conn => conn.id !== connectionId))
    onConnectionDelete?.(connectionId)
  }, [onConnectionDelete])

  // ìœ íš¨í•˜ì§€ ì•Šì€ ì—°ê²° ì •ë¦¬ (ì£¼ê¸°ì ìœ¼ë¡œ ì‹¤í–‰)
  React.useEffect(() => {
    const cleanupInvalidConnections = () => {
      if (internalConnections.length === 0) return

      const allGridElements = document.querySelectorAll('[data-grid-id]')
      const existingGridIds = new Set<string>()
      allGridElements.forEach(element => {
        const gridId = element.getAttribute('data-grid-id')
        if (gridId) existingGridIds.add(gridId)
      })

      const validConnections = internalConnections.filter(connection => {
        const sourceExists = existingGridIds.has(String(connection.sourceGridId))
        const targetExists = existingGridIds.has(String(connection.targetGridId))
        return sourceExists && targetExists
      })

      if (validConnections.length !== internalConnections.length) {
        setInternalConnections(validConnections)
      }
    }

    // 5ì´ˆë§ˆë‹¤ ì •ë¦¬ ì‘ì—… ì‹¤í–‰
    const cleanupInterval = setInterval(cleanupInvalidConnections, 5000)
    
    return () => clearInterval(cleanupInterval)
  }, [internalConnections])

  // ì „ì²´ ê·¸ë¦¬ë“œ í¬ê¸° ê³„ì‚°
  const gridDimensions = React.useMemo(() => {
    // ë¸”ë¡ëª… í–‰ ê°œìˆ˜ëŠ” ë¬´ì¡°ê±´ 1ê°œ
    const blockNameRows = 1
    
    // í—¤ë” í–‰ ê°œìˆ˜ëŠ” ë¬´ì¡°ê±´ 1ê°œ
    const headerRows = 1
    
    // êµ¬ë¶„ ë¸”ë¡ì˜ ë¦¬í”„ ì…€ ê°œìˆ˜ ê³„ì‚°
    let maxBodyRows = 1 // ê¸°ë³¸ê°’: êµ¬ë¶„ ë¸”ë¡ì´ ì—†ëŠ” ê²½ìš° 1ê°œ
    
    blocks.forEach(block => {
      if (isDivisionBlock(block)) {
        // êµ¬ë¶„ ë¸”ë¡ì˜ ë¦¬í”„ ì…€ ê°œìˆ˜ ê³„ì‚°
        const hierarchicalData = hierarchicalDataMap[block.id] || []
        const leafCells = HierarchicalCellUtils.getLeafCells(hierarchicalData)
        maxBodyRows = Math.max(maxBodyRows, leafCells.length)
      }
    })
    
    // ëª¨ë“  ë¸”ë¡ì˜ ì—´ ê°œìˆ˜ í•©ê³„ ê³„ì‚°
    let totalCols = 0
    blocks.forEach(block => {
      const gridSize = BlockGridCalculator.calculateGridSize(block)
      totalCols += gridSize.cols
    })
    
    // ComponentGrid ì´ í–‰ ìˆ˜ = ë¸”ë¡ëª… í–‰(1ê°œ) + í—¤ë” í–‰ ê°œìˆ˜ + ë°”ë”” í–‰ ê°œìˆ˜
    const totalRows = blockNameRows + headerRows + maxBodyRows
    console.log('ğŸ”§ ComponentGrid í¬ê¸°:', {
      'ë¸”ë¡ëª… í–‰ ìˆ˜': blockNameRows,
      'í—¤ë” í–‰ ìˆ˜': headerRows,
      'ë°”ë”” í–‰ ìˆ˜': maxBodyRows,
      'ì´ í–‰ ìˆ˜': totalRows,
      'ì´ ì—´ ìˆ˜': totalCols,
    })
    
    return {
      totalRows,
      totalCols,
      blockNameRows,
      headerRows,
      bodyRows: maxBodyRows
    }
  }, [blocks, hierarchicalDataMap])

  // ë¸”ë¡ ë³€ê²½ ì‹œ ê·¸ë¦¬ë“œ í¬ê¸° ì½˜ì†” ì¶œë ¥
  // React.useEffect(() => {
  //   if (blocks.length > 0) {
  //     console.log('ğŸ”§ ComponentGrid í¬ê¸°:', {
  //       'ì´ í–‰ ìˆ˜': gridDimensions.totalRows,
  //       'ì´ ì—´ ìˆ˜': gridDimensions.totalCols,
  //       'ë¸”ë¡ëª… í–‰ ìˆ˜': gridDimensions.blockNameRows,
  //       'í—¤ë” í–‰ ìˆ˜': gridDimensions.headerRows,
  //       'ë°”ë”” í–‰ ìˆ˜': gridDimensions.bodyRows,
  //       'ë¸”ë¡ ìˆ˜': blocks.length,
  //       'êµ¬ë¶„ ë¸”ë¡ ìˆ˜': blocks.filter(isDivisionBlock).length,
  //       'ì¼ë°˜ ë¸”ë¡ ìˆ˜': blocks.filter(block => !isDivisionBlock(block)).length
  //     })
  //   }
  // }, [gridDimensions, blocks])

  // ê·¸ë¦¬ë“œ ìŠ¤íƒ€ì¼ ê³„ì‚°
  const gridStyle = React.useMemo(() => {
    return {
      display: 'grid',
      gridTemplateColumns: `repeat(${gridDimensions.totalCols}, 1fr)`,
      gridTemplateRows: `repeat(${gridDimensions.totalRows}, auto)`,
      gap: '1px',
      border: '1px solid #3b82f6',
    }
  }, [gridDimensions])

  // (r,c) ì¢Œí‘œì— í•´ë‹¹í•˜ëŠ” ë¸”ë¡ê³¼ ì…€ ì •ë³´ë¥¼ ì°¾ëŠ” í—¬í¼ í•¨ìˆ˜
  const findCellAtPosition = React.useCallback((row: number, col: number) => {
    // ë¸”ë¡ëª… í–‰ì¸ì§€ í™•ì¸
    const isBlockNameRow = row < gridDimensions.blockNameRows
    // í—¤ë” í–‰ì¸ì§€ í™•ì¸
    const isHeaderRow = row >= gridDimensions.blockNameRows && row < gridDimensions.blockNameRows + gridDimensions.headerRows
    
    for (const block of blocks) {
      const blockInfo = gridInfo.blocks.find(b => b.blockId === block.id)
      if (!blockInfo) continue
      
      // í•´ë‹¹ ë¸”ë¡ì˜ ë²”ìœ„ í™•ì¸
      const blockStartCol = blockInfo.startCol
      const blockEndCol = blockInfo.startCol + blockInfo.colSpan - 1
      
      if (col < blockStartCol || col > blockEndCol) continue
      
      const relativeCol = col - blockStartCol
      
      if (isHeaderRow) {
        // í—¤ë” ì…€ ì²˜ë¦¬
        if (isDivisionBlock(block)) {
          return {
            type: 'header',
            block,
            blockInfo,
            cell: { elements: [...(block.type.header || [])] },
            onChange: (elementIndex: number, value: any) => {
              onBlockChange?.(block.id, ['type', 'header', elementIndex], value)
            }
          }
        } else if (block.type.cols && block.type.cols[relativeCol]) {
          return {
            type: 'header',
            block,
            blockInfo,
            cell: block.type.cols[relativeCol].header,
            onChange: (elementIndex: number, value: any) => {
              onBlockChange?.(block.id, ['type', 'cols', relativeCol, 'header', 'elements', elementIndex], value)
            }
          }
        }
      } else if (!isBlockNameRow) {
        // ë°”ë”” ì…€ ì²˜ë¦¬
        const bodyRow = row - gridDimensions.blockNameRows - gridDimensions.headerRows
        
        if (isDivisionBlock(block)) {
          const cols = Array.isArray(block.type.header) ? block.type.header.length : 1
          if (relativeCol >= cols) return null

          const leaves = HierarchicalCellUtils.getLeafCells(hierarchicalDataMap[block.id] || [])
          if (bodyRow < leaves.length) {
            const leaf = leaves[bodyRow] as any
            const element = (leaf.value?.elements || [])[relativeCol]
            if (element) {
              return {
                type: 'body',
                block,
                blockInfo,
                cell: { elements: [element] },
                onChange: (elementIndex: number, value: any) => {
                  onBlockChange?.(block.id, ['type', 'children'], (block.type as any).children)
                }
              }
            }
          }
          return null
        } else if (block.type.cols && block.type.cols[relativeCol]) {
          const colData = block.type.cols[relativeCol]
          if (colData.rows && colData.rows[bodyRow]) {
            return {
              type: 'body',
              block,
              blockInfo,
              cell: colData.rows[bodyRow],
              onChange: (elementIndex: number, value: any) => {
                onBlockChange?.(block.id, ['type', 'cols', relativeCol, 'rows', bodyRow, 'elements', elementIndex], value)
              }
            }
          }
        }
      }
    }
    
    return null
  }, [blocks, gridInfo, gridDimensions, divisionGridStateMap, onBlockChange])
  
  // ë¸”ë¡ëª… ë Œë”ë§
  const renderBlockNames = () => {
    return gridInfo.blocks.map((blockInfo) => (
      <div
        key={`block-name-${blockInfo.blockId}`}
        style={{ 
          gridArea: getBlockNameGridArea(blockInfo),
          backgroundColor: blocks.find(b => b.id === blockInfo.blockId)?.type.color || '#blue',
        }}
        className="p-2 text-center text-xs font-semibold text-white bg-blue-500 border border-gray-300 flex items-center justify-between"
      >
        <span>{blockInfo.blockName}</span>
        <div className="flex items-center gap-1">
          {/* ì—´ ì¶”ê°€ ë²„íŠ¼ */}
          {blocks.find(b => b.id === blockInfo.blockId)?.type.col_editable && onAddColumn && (
            <button
              onClick={(e) => {
                e.stopPropagation()
                const targetBlock = blocks.find(b => b.id === blockInfo.blockId)
                if (targetBlock && isDivisionBlock(targetBlock)) {
                  // êµ¬ë¶„ ë¸”ë¡ì¸ ê²½ìš° hierarchicalDataMapë„ ì—…ë°ì´íŠ¸
                  handleAddColumnForDivisionBlock(blockInfo.blockId)
                }
                onAddColumn(blockInfo.blockId)
              }}
              className="bg-green-600 text-white px-2 py-1 rounded text-xs hover:bg-green-700"
              title="ì—´ ì¶”ê°€"
            >
              +ì—´
            </button>
          )}
          {/* ë°ì´í„° ë³´ê¸° ë²„íŠ¼ (ì‚­ì œ ë²„íŠ¼ ì™¼ìª½) */}
          <button
            onClick={(e) => {
              e.stopPropagation()
              const targetBlock = blocks.find(b => b.id === blockInfo.blockId)
              if (targetBlock) {
                logBlockAsDbFormat(targetBlock, 1, blockInfo.blockId)
              }
            }}
            className="bg-blue-600 text-white p-1 rounded hover:bg-blue-700"
            title="ë°ì´í„° ë³´ê¸°"
          >
            <Eye className="w-4 h-4" />
          </button>
          {/* ì‚­ì œ ë²„íŠ¼ (ê²°í•© ë²„íŠ¼ì˜ ì™¼ìª½) */}
          {onBlockDelete && (
            <button
              onClick={(e) => {
                e.stopPropagation()
                onBlockDelete(blockInfo.blockId)
              }}
              className="bg-red-600 text-white p-1 rounded hover:bg-red-700"
              title="ì‚­ì œ"
            >
              <Trash2 className="w-4 h-4" />
            </button>
          )}
          {/* ê²°í•© ë²„íŠ¼ */}
          {onBlockCombine && (
            <CombineButton 
              blockId={blockInfo.blockId} 
              combineState={combineState}
              onCombine={onBlockCombine}
            />
          )}
        </div>
      </div>
    ))
  }
  
  // í—¤ë” ì…€ë“¤ ë Œë”ë§ (ì´ì¤‘ ë°˜ë³µë¬¸ êµ¬ì¡°)
  const renderHeaders = () => {
    const cells: React.ReactNode[] = []
    
    // í—¤ë” í–‰ë“¤ì„ ìˆœíšŒ (ë¸”ë¡ëª… í–‰ ë‹¤ìŒë¶€í„°)
    for (let row = gridDimensions.blockNameRows; row < gridDimensions.blockNameRows + gridDimensions.headerRows; row++) {
      for (let col = 0; col < gridDimensions.totalCols; col++) {
        const cellInfo = findCellAtPosition(row, col)
        console.log(`${row} ${col} ${cellInfo?.type} ${cellInfo?.cell}`)
        
        if (cellInfo && cellInfo.type === 'header' && cellInfo.cell) {
          const relativeRow = row - gridDimensions.blockNameRows
          const gridArea = getHeaderGridArea(cellInfo.blockInfo, relativeRow, col - cellInfo.blockInfo.startCol)
          
          cells.push(
            <Cell
              key={`header-${row}-${col}`}
              cell={cellInfo.cell}
              style={{ gridArea }}
              className="bg-gray-50"
              onChange={cellInfo.onChange}
            />
          )
        }
      }
    }
    
    return cells
  }
  
  // ë°”ë”” ì…€ë“¤ ë Œë”ë§ (ì´ì¤‘ ë°˜ë³µë¬¸ êµ¬ì¡°)
  const renderBodies = () => {
    const cells: React.ReactNode[] = []
    
    // ë°”ë”” í–‰ë“¤ì„ ìˆœíšŒ (ë¸”ë¡ëª… + í—¤ë” í–‰ ë‹¤ìŒë¶€í„°)
    const bodyStartRow = gridDimensions.blockNameRows + gridDimensions.headerRows
    for (let row = bodyStartRow; row < gridDimensions.totalRows; row++) {
      for (let col = 0; col < gridDimensions.totalCols; col++) {
        const cellInfo = findCellAtPosition(row, col)
        
        if (cellInfo && cellInfo.type === 'body') {
          const bodyRow = row - bodyStartRow
          const relativeCol = col - cellInfo.blockInfo.startCol
          const gridArea = getBodyGridArea(cellInfo.blockInfo, bodyRow, relativeCol, gridDimensions.headerRows)
          
          if (cellInfo.cell) {
            // ì¼ë°˜ ì…€ ë Œë”ë§
            cells.push(
              <Cell
                key={`body-${row}-${col}`}
                cell={cellInfo.cell}
                style={{ gridArea }}
                className="bg-white border border-green-400/60"
                onChange={cellInfo.onChange}
              />
            )
          } else if ((cellInfo as any).merge) {
            // DivisionBlockì˜ ê¸°ë³¸ ì…€ ë Œë”ë§ (í–‰ ì¶”ê°€ ë²„íŠ¼ í¬í•¨)
            const rowSpan = Math.max(1, (cellInfo as any).merge.rowspan || 1)
            cells.push(
              <div
                key={`body-${row}-${col}`}
                style={{ gridArea }}
                className="relative bg-white border border-green-400/60"
              >
                <div className="text-xs text-gray-400 p-2">ì»¬ëŸ¼ ìœ í˜•ì„ ì„ íƒí•˜ì„¸ìš”</div>
                <button
                  className="absolute bottom-0 left-0 right-0 h-[20%] bg-green-500 hover:bg-green-600 text-white text-xs"
                  onClick={(e) => { 
                    e.preventDefault(); 
                    e.stopPropagation(); 
                    handleDivisionAddRow(cellInfo.block.id, (cellInfo as any).bodyRow, (cellInfo as any).relativeCol) 
                  }}
                  title="í–‰ ì¶”ê°€"
                >
                  í–‰ ì¶”ê°€ 
                </button>
                <div style={{ position: 'absolute', inset: 0, pointerEvents: 'none' }} />
                <style jsx>{`
                  div[style*="grid-area"] { grid-row-end: span ${rowSpan}; }
                `}</style>
              </div>
            )
          }
        }
      }
    }
    
    return cells
  }
  
  if (blocks.length === 0) {
    return null
  }
  
  return (
    <>
      <div 
        style={{
          ...gridStyle,
          position: 'relative'
        }} 
        className="component-grid"
        data-grid-id={stableGridId}
      >
        {renderBlockNames()}
        {renderHeaders()}
        {renderBodies()}
        
        {/* ì—°ê²° í•¸ë“¤ */}
        <ConnectionHandle
          position="left"
          gridId={stableGridId}
          onConnectionStart={handleConnectionStart}
          onConnectionEnd={handleConnectionEnd}
          isDragging={connectionDragState.isDragging && connectionDragState.sourceGridId === stableGridId}
        />
        <ConnectionHandle
          position="right"
          gridId={stableGridId}
          onConnectionStart={handleConnectionStart}
          onConnectionEnd={handleConnectionEnd}
          isDragging={connectionDragState.isDragging && connectionDragState.sourceGridId === stableGridId}
        />
      </div>
      
      {/* ì—°ê²°ì„  ë Œë”ë§ */}
      <ConnectionLine 
        connections={activeConnections}
        onConnectionDelete={handleInternalConnectionDelete}
      />
    </>
  )
}

// DivisionDataConverter ëŒ€ì²´ í•¨ìˆ˜ë“¤
const createSampleHierarchy = (): HierarchicalCell[] => {
  return [
    {
      id: 'sample-1',
      type: 'Token',
      value: { value: 'ìƒ˜í”Œ', menu_key: 'division_values', optional: false, visible: true },
      level: 0,
      children: [],
      parent: undefined
    }
  ]
}

const hierarchicalToFlat = (hierarchicalData: HierarchicalCell[]) => {
  const rows: any[] = []
  
  const processCell = (cell: HierarchicalCell, depth: number = 0) => {
    const row: any = {
      elements: [cell.value],
      depth,
      children: cell.children.length
    }
    rows.push(row)
    
    cell.children.forEach(child => processCell(child, depth + 1))
  }
  
  hierarchicalData.forEach(cell => processCell(cell))
  
  return { rows }
}

// ê²°í•© ë²„íŠ¼ ì»´í¬ë„ŒíŠ¸
interface CombineButtonProps {
  blockId: number
  combineState?: {
    isCombineMode: boolean
    sourceBlockId: string | null
    targetBlockId: string | null
  }
  onCombine: (blockId: number, side?: 'left' | 'right') => void
}

const CombineButton: React.FC<CombineButtonProps> = ({ blockId, combineState, onCombine }) => {
  const isCombineMode = combineState?.isCombineMode || false
  const isCombining = combineState?.sourceBlockId === String(blockId)
  
  const getCombineButtonStyle = () => {
    if (!isCombineMode) {
      return "bg-blue-600 text-white p-1 rounded hover:bg-blue-700"
    }
    
    if (isCombining) {
      return "bg-yellow-500 text-white p-1 rounded hover:bg-yellow-600"
    }
    
    return "bg-green-500 text-white p-1 rounded hover:bg-green-600"
  }
  
  if (!isCombineMode) {
    return (
      <button 
        className={getCombineButtonStyle()}
        onClick={(e) => {
          e.stopPropagation()
          onCombine(blockId)
        }}
        title="ê²°í•©"
      >
        <Link2 className="w-4 h-4" />
      </button>
    )
  }
  
  if (isCombining) {
    return (
      <button 
        className={getCombineButtonStyle()}
        onClick={(e) => {
          e.stopPropagation()
          onCombine(blockId)
        }}
        title="ê²°í•© ì·¨ì†Œ"
      >
        <X className="w-4 h-4" />
      </button>
    )
  }
  
  return (
    <div className="flex gap-1">
      <button 
        className={getCombineButtonStyle()}
        onClick={(e) => {
          e.stopPropagation()
          onCombine(blockId, 'left')
        }}
        title="ì™¼ìª½ì— ê²°í•©"
      >
        <ArrowLeft className="w-4 h-4" />
      </button>
      <button 
        className={getCombineButtonStyle()}
        onClick={(e) => {
          e.stopPropagation()
          onCombine(blockId, 'right')
        }}
        title="ì˜¤ë¥¸ìª½ì— ê²°í•©"
      >
        <ArrowRight className="w-4 h-4" />
      </button>
    </div>
  )
}

// ì—°ê²° í•¸ë“¤ ì»´í¬ë„ŒíŠ¸
interface ConnectionHandleProps {
  position: 'left' | 'right'
  gridId: number
  onConnectionStart: (gridId: number, handle: 'left' | 'right') => void
  onConnectionEnd: (gridId: number, handle: 'left' | 'right') => void
  isDragging: boolean
}

const ConnectionHandle: React.FC<ConnectionHandleProps> = ({
  position,
  gridId,
  onConnectionStart,
  onConnectionEnd,
  isDragging
}) => {
  const [isHovered, setIsHovered] = React.useState(false)

  const handleMouseDown = React.useCallback((e: React.MouseEvent) => {
    e.preventDefault()
    e.stopPropagation()
    
    onConnectionStart(gridId, position)
    
    // ì „ì—­ ë§ˆìš°ìŠ¤ì—… ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
    const handleGlobalMouseUp = (globalEvent: MouseEvent) => {
      // ë§ˆìš°ìŠ¤ì—…ì´ ë°œìƒí•œ ìœ„ì¹˜ì—ì„œ ë‹¤ë¥¸ í•¸ë“¤ ì°¾ê¸°
      const elementUnderMouse = document.elementFromPoint(globalEvent.clientX, globalEvent.clientY)
      
      const targetHandle = elementUnderMouse?.closest('[data-connection-handle]')
      
      if (targetHandle) {
        const targetGridId = parseInt(targetHandle.getAttribute('data-grid-id') || '0')
        const targetPosition = targetHandle.getAttribute('data-position') as 'left' | 'right'
        
        if (targetGridId !== gridId) {
          onConnectionEnd(targetGridId, targetPosition)
        } else {
          onConnectionEnd(gridId, position) // ì·¨ì†Œ
        }
      } else {
        // ë‹¤ë¥¸ ë°©ë²•ìœ¼ë¡œ í•¸ë“¤ ì°¾ê¸° ì‹œë„
        const allHandles = document.querySelectorAll('[data-connection-handle]')
        
        let foundTarget = false
        allHandles.forEach(handle => {
          const rect = handle.getBoundingClientRect()
          const distance = Math.sqrt(
            Math.pow(globalEvent.clientX - (rect.left + rect.width / 2), 2) +
            Math.pow(globalEvent.clientY - (rect.top + rect.height / 2), 2)
          )
          
          if (distance < 20) { // 20px ì´ë‚´ë©´ ì—°ê²° ëŒ€ìƒìœ¼ë¡œ ê°„ì£¼
            const targetGridId = parseInt(handle.getAttribute('data-grid-id') || '0')
            const targetPosition = handle.getAttribute('data-position') as 'left' | 'right'
            
            
            if (targetGridId !== gridId) {
              onConnectionEnd(targetGridId, targetPosition)
              foundTarget = true
            }
          }
        })
        
        if (!foundTarget) {
          onConnectionEnd(gridId, position) // ì·¨ì†Œ
        }
      }
      
      // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
      document.removeEventListener('mouseup', handleGlobalMouseUp)
    }
    
    document.addEventListener('mouseup', handleGlobalMouseUp)
  }, [gridId, position, onConnectionStart, onConnectionEnd])

  const handleStyle: React.CSSProperties = {
    position: 'absolute',
    top: '50%',
    transform: 'translateY(-50%)',
    width: '12px',
    height: '12px',
    borderRadius: '50%',
    backgroundColor: isDragging ? '#10b981' : isHovered ? '#22c55e' : '#3b82f6',
    border: '2px solid white',
    cursor: isDragging ? 'grabbing' : 'grab',
    zIndex: 10,
    transition: 'background-color 0.2s ease',
    ...(position === 'left' ? { left: '-6px' } : { right: '-6px' })
  }

  return (
    <div
      style={handleStyle}
      onMouseDown={handleMouseDown}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      data-connection-handle="true"
      data-grid-id={gridId}
      data-position={position}
      title={`${position === 'left' ? 'ì™¼ìª½' : 'ì˜¤ë¥¸ìª½'} ì—°ê²° í•¸ë“¤ - ë“œë˜ê·¸í•˜ì—¬ ì—°ê²°í•˜ì„¸ìš”`}
    />
  )
}

// ì—°ê²°ì„  ë Œë”ë§ ì»´í¬ë„ŒíŠ¸
interface ConnectionLineProps {
  connections: Connection[]
  onConnectionDelete?: (connectionId: string) => void
}

const ConnectionLine: React.FC<ConnectionLineProps> = ({ connections, onConnectionDelete }) => {
  const [lineElements, setLineElements] = React.useState<React.ReactNode[]>([])

  React.useEffect(() => {
    if (connections.length === 0) {
      setLineElements([])
      return
    }

    // í˜„ì¬ DOMì— ì¡´ì¬í•˜ëŠ” ëª¨ë“  ê·¸ë¦¬ë“œ ID ìˆ˜ì§‘
    const allGridElements = document.querySelectorAll('[data-grid-id]')
    const existingGridIds = new Set<string>()
    allGridElements.forEach(element => {
      const gridId = element.getAttribute('data-grid-id')
      if (gridId) existingGridIds.add(gridId)
    })
    
    // ìœ íš¨í•œ ì—°ê²°ë§Œ í•„í„°ë§
    const validConnections = connections.filter(connection => {
      const sourceExists = existingGridIds.has(String(connection.sourceGridId))
      const targetExists = existingGridIds.has(String(connection.targetGridId))
      
      if (!sourceExists || !targetExists) {
        console.warn('ìœ íš¨í•˜ì§€ ì•Šì€ ì—°ê²° ë°œê²¬:', {
          connectionId: connection.id,
          sourceGridId: connection.sourceGridId,
          targetGridId: connection.targetGridId,
          sourceExists,
          targetExists
        })
        return false
      }
      return true
    })


    if (validConnections.length === 0) {
      setLineElements([])
      return
    }

    // ì¬ì‹œë„ ë¡œì§ìœ¼ë¡œ ì•ˆì •ì„± ê°•í™”
    let retryCount = 0
    const maxRetries = 3
    const retryDelay = 100

    const processConnections = () => {
      const elements = validConnections.map((connection) => {
        // ì†ŒìŠ¤ì™€ íƒ€ê²Ÿ ê·¸ë¦¬ë“œ ìš”ì†Œ ì°¾ê¸°
        const sourceElement = document.querySelector(`[data-grid-id="${connection.sourceGridId}"]`)
        const targetElement = document.querySelector(`[data-grid-id="${connection.targetGridId}"]`)
        
        
        if (!sourceElement || !targetElement) {
          console.warn(`ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ (ì‹œë„ ${retryCount + 1}/${maxRetries}):`, {
            sourceGridId: connection.sourceGridId,
            targetGridId: connection.targetGridId,
            sourceElement: !!sourceElement,
            targetElement: !!targetElement
          })
          return null
        }

        const sourceRect = sourceElement.getBoundingClientRect()
        const targetRect = targetElement.getBoundingClientRect()
        
        // ì—°ê²°ì  ê³„ì‚°
        const sourceX = connection.sourceHandle === 'left' 
          ? sourceRect.left 
          : sourceRect.right
        const sourceY = sourceRect.top + sourceRect.height / 2
        
        const targetX = connection.targetHandle === 'left' 
          ? targetRect.left 
          : targetRect.right
        const targetY = targetRect.top + targetRect.height / 2


        // SVG ê²½ë¡œ ìƒì„± (ë² ì§€ì–´ ê³¡ì„ )
        const midX = (sourceX + targetX) / 2
        const path = `M ${sourceX} ${sourceY} Q ${midX} ${sourceY} ${midX} ${targetY} Q ${midX} ${targetY} ${targetX} ${targetY}`

        return (
          <g key={connection.id}>
            {/* ì—°ê²°ì„  */}
            <path
              d={path}
              stroke="#3b82f6"
              strokeWidth="3"
              fill="none"
              markerEnd="url(#arrowhead)"
            />
            {/* ì‚­ì œ ë²„íŠ¼ */}
            <circle
              cx={midX}
              cy={(sourceY + targetY) / 2}
              r="10"
              fill="#ef4444"
              className="cursor-pointer hover:fill-red-600"
              onClick={() => onConnectionDelete?.(connection.id)}
            />
            <text
              x={midX}
              y={(sourceY + targetY) / 2 + 2}
              textAnchor="middle"
              fontSize="12"
              fill="white"
              className="pointer-events-none"
              fontWeight="bold"
            >
              Ã—
            </text>
          </g>
        )
      })

      const validElements = elements.filter(Boolean)
      
      // ëª¨ë“  ì—°ê²°ì´ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆê±°ë‚˜ ìµœëŒ€ ì¬ì‹œë„ì— ë„ë‹¬í•œ ê²½ìš°
      if (validElements.length === validConnections.length || retryCount >= maxRetries) {
        setLineElements(validElements)
      } else {
        // ì¼ë¶€ ìš”ì†Œë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° ì¬ì‹œë„
        retryCount++
        setTimeout(processConnections, retryDelay)
      }
    }

    const timer = setTimeout(processConnections, 100)

    return () => clearTimeout(timer)
  }, [connections, onConnectionDelete])

  if (connections.length === 0) return null

  return (
    <svg
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: 1000
      }}
    >
      {/* í™”ì‚´í‘œ ë§ˆì»¤ ì •ì˜ */}
      <defs>
        <marker
          id="arrowhead"
          markerWidth="10"
          markerHeight="7"
          refX="9"
          refY="3.5"
          orient="auto"
        >
          <polygon
            points="0 0, 10 3.5, 0 7"
            fill="#3b82f6"
          />
        </marker>
      </defs>
      <g style={{ pointerEvents: 'auto' }}>
        {lineElements}
      </g>
    </svg>
  )
}